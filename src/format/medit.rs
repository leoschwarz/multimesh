use data::{Attr, Group, GroupKind};
use de::DeserializeMesh;
use ser::{SerializableMesh, SerializableGroup, SerializableNodeGroup, SerializableNode, Serializer, SerializableElementGroup, SerializableElement};
use nalgebra::DVector;
use regex::{Regex, RegexBuilder};
use std::collections::VecDeque;
use std::fmt::Display;
use std::io::{self, Read, Write};
use std::marker::PhantomData;
use std::str::{FromStr, Lines};

#[derive(Debug)]
pub enum DeserializeError {
    /// There was a problem with I/O.
    Io(io::Error),

    /// Unsupported version or format encounterd.
    Unsupported(String),

    /// Parsing the data failed for one of many possible reasons.
    Parse(String),
}

pub enum SerializeError {
    Io(io::Error),
}

impl From<io::Error> for SerializeError {
    fn from(e: io::Error) -> Self {
        SerializeError::Io(e)
    }
}

pub struct MeditSerializer {
}

impl MeditSerializer {
    pub fn new() -> Self {
        MeditSerializer {}
    }
}

impl Serializer for MeditSerializer {
    type Error = SerializeError;

    fn serialize<M, W>(&self, mesh: M, mut target: W) -> Result<(), SerializeError>
        where M: SerializableMesh, W: Write {
        // TODO: include version information of crate
        writeln!(target, "MeshVersionFormatted 1")?;
        writeln!(target, "# MEDIT mesh file, generated by multimesh")?;

        // Get dimensionality.
        let mesh_dim = mesh.metadata().dimension();
        // TODO: handle other dimensions, remove assert
        assert!(mesh_dim == 2 || mesh_dim == 3);
        writeln!(target, "Dimension {}\n", mesh_dim)?;

        for node_group in mesh.node_groups() {
            let group_metadata = node_group.metadata();
            // TODO: allow and check all other possible group names or return error instead of panic
            assert_eq!(group_metadata.name(), "Vertices");

            writeln!(target, "{}\n{}", group_metadata.name(), group_metadata.len())?;
            for i in 0..group_metadata.len() {
                // TODO remove unwrap
                let node = node_group.item_at(i).unwrap();
                let p = node.position();
                let attr = node.attr().get(0).unwrap_or(0.);
                if mesh_dim == 2 {
                    writeln!(target, "{} {} {}", p[0], p[1], attr)?;
                } else if mesh_dim == 3 {
                    writeln!(target, "{} {} {} {}", p[0], p[1], p[2], attr)?;
                } else {
                    // TODO
                    panic!("unsupported");
                }
            }
            writeln!(target, "")?;
        }

        for el_group in mesh.element_groups() {
            let group_metadata = el_group.metadata();
            // TODO: allow and check all other possible group names or return error instead of panic
            assert_eq!(group_metadata.name(), "Triangles");
            writeln!(target, "{}\n{}", group_metadata.name(), group_metadata.len())?;
            for i in 0..group_metadata.len() {
                // TODO remove unwrap
                let element = el_group.item_at(i).unwrap();
                let is = element.node_indices().unwrap();
                let attr = element.attr().get(0).unwrap_or(0.);
                let nary = 3;
                assert_eq!(nary, 3);

                writeln!(target, "{} {} {} {}", is[0], is[1], is[2], attr)?;
            }
            writeln!(target, "")?;
        }

        writeln!(target, "End")?;

        Ok(())
    }
}

pub struct MeditDeserializer {}

// TODO convert to trait
impl MeditDeserializer {
    pub fn read<S, T>(mut source: S, mut target: T) -> Result<(), DeserializeError>
    where
        S: Read,
        T: DeserializeMesh,
    {
        // Read the file into memory.
        let mut data = String::new();
        source
            .read_to_string(&mut data)
            .map_err(|e| DeserializeError::Io(e))?;
        let mut reader = ItemReader::new(data.as_ref());

        // Read data.
        let mut version: Option<&str> = None;
        let mut dimension: usize = 0;
        let mut parsing_uid: u64 = 0;

        while let Some(keyword) = reader.next() {
            match keyword {
                "MeshVersionFormatted" => {
                    version = Some(reader.get_next()?);
                    if version != Some("1") {
                        return Err(DeserializeError::Parse(format!(
                            "Unsupported version: {}",
                            version.unwrap()
                        )));
                    }
                }
                "Dimension" => {
                    dimension = reader
                        .get_next()?
                        .parse()
                        .map_err(|_| DeserializeError::Parse("Dimension".into()))?;
                    target.de_dimension(dimension as u8);
                }
                "Vertices" => {
                    if dimension == 0 {
                        return Err(DeserializeError::Parse("Bad dimension.".into()));
                    }

                    let num_nodes: usize = reader.get_val()?;

                    parsing_uid += 1;
                    let group =
                        Group::new(parsing_uid, "Vertices", Some(num_nodes), GroupKind::Node);
                    target.de_group_begin(&group);

                    for _ in 0..num_nodes {
                        let mut position = DVector::<f64>::zeros(dimension);
                        for i in 0..dimension {
                            position[i] = reader.get_val()?;
                        }
                        let mut attr = Attr::new();
                        attr.insert(0, reader.get_val()?);

                        target.de_node(position, attr, &group);
                    }

                    target.de_group_end(&group);
                }
                "Triangles" => {
                    let num_elements: usize = reader.get_val()?;

                    parsing_uid += 1;
                    let group = Group::new(
                        parsing_uid,
                        "Triangles",
                        Some(num_elements),
                        GroupKind::Element,
                    );
                    target.de_group_begin(&group);

                    for _ in 0..num_elements {
                        let mut indices = DVector::<usize>::from_element(3, 0);
                        for i_no in 0..3 {
                            indices[i_no] = reader.get_val()?;
                        }
                        let mut attr = Attr::new();
                        attr.insert(0, reader.get_val()?);
                        target.de_element((indices, attr), &group);
                    }

                    target.de_group_end(&group);
                }
                "End" => {
                    // TODO: Maybe it would be better to set a flag and check
                    // if there is more content anyway, the problem with this
                    // is that there might be an obscure convention where someone
                    // puts different data after the end keyword, or if reading
                    // from a stream of multiple medit meshes.
                    return Ok(());
                }
                other => {
                    if other.trim().is_empty() || other.starts_with("#") {
                        // Ignore.
                    } else {
                        return Err(DeserializeError::Parse(format!(
                            "Unsupported keyword: {}",
                            other
                        )));
                    }
                }
            }
        }

        Ok(())
    }
}

struct ItemReader<'s> {
    lines: Lines<'s>,
    line_buf: VecDeque<&'s str>,
}

impl<'s> ItemReader<'s> {
    fn new(data: &'s str) -> Self {
        ItemReader {
            lines: data.lines(),
            line_buf: VecDeque::new(),
        }
    }

    fn get_val<T>(&mut self) -> Result<T, DeserializeError>
    where
        T: FromStr,
        <T as FromStr>::Err: Display,
    {
        self.get_next().and_then(|s| {
            s.parse()
                .map_err(|e| DeserializeError::Parse(format!("Parse value failed: {}", e)))
        })
    }

    fn get_next(&mut self) -> Result<&'s str, DeserializeError> {
        self.next()
            .ok_or_else(|| DeserializeError::Parse("Unexpected EOF".into()))
    }
}

impl<'s> Iterator for ItemReader<'s> {
    type Item = &'s str;

    fn next(&mut self) -> Option<Self::Item> {
        let probe_buf = |line_buf: &mut VecDeque<&'s str>| {
            while let Some(item) = line_buf.remove(0) {
                if !item.trim().is_empty() {
                    return Some(item);
                }
            }
            None
        };

        if let Some(item) = probe_buf(&mut self.line_buf) {
            return Some(item);
        }

        lazy_static! {
            static ref RE: Regex = Regex::new(r"\s+").unwrap();
        }

        while let Some(line) = self.lines.next() {
            if !line.starts_with("#") && !line.trim().is_empty() {
                self.line_buf.extend(RE.split(line));
                if let Some(item) = probe_buf(&mut self.line_buf) {
                    return Some(item);
                }
            }
        }

        None
    }
}

mod tests {
    use super::*;

    #[test]
    fn item_reader() {
        let source = " abc   xyz  -1\n\r\t \n  abc xyz";
        let mut reader = ItemReader::new(source);

        assert_eq!(reader.next(), "abc".into());
        assert_eq!(reader.next(), "xyz".into());
        assert_eq!(reader.next(), "-1".into());
        assert_eq!(reader.next(), "abc".into());
        assert_eq!(reader.next(), "xyz".into());
        assert_eq!(reader.next(), None);
    }
}
